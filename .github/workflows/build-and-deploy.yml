name: Build and Test

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16
        ports:
          - 5432:5432
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd="pg_isready -U testuser"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    env:
      NODE_ENV: test
      DB_HOST: localhost
      DB_PORT: 5432
      DB_USERNAME: testuser
      DB_PASSWORD: testpass
      DB_NAME: testdb

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Run linter
        run: npm run lint

      - name: Run tests with coverage
        run: npm run test:cov
      
      - name: Run e2e tests
        run: npm run test:e2e

      - name: Upload coverage reports
        uses: codecov/codecov-action@v4
        if: success()
        with:
          file: ./coverage/lcov.info
          flags: unittests
          fail_ci_if_error: false
        continue-on-error: true

      - name: Archive coverage results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: coverage/
          retention-days: 7

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: test
    outputs:
      artifact_name: ${{ steps.vars.outputs.artifact_name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Get version and commit hash
        id: vars
        run: |
          VERSION=$(node -p "require('./package.json').version")
          GIT_HASH=$(git rev-parse --short=7 HEAD)
          ARTIFACT="dist-v${VERSION}-${GIT_HASH}.tar.gz"
          echo "artifact_name=$ARTIFACT" >> $GITHUB_OUTPUT

      - name: Archive production build
        run: |
          tar -czf "${{ steps.vars.outputs.artifact_name }}" \
            package.json \
            package-lock.json \
            nest-cli.json \
            ecosystem.config.cjs \
            DESCRIPTION.md \
            README.md \
            dist

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.vars.outputs.artifact_name }}
          path: ${{ steps.vars.outputs.artifact_name }}
          retention-days: 30

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main')

    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.artifact_name }}
          path: ./

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DROPLET_KEY }}

      - name: Copy artifact to droplet
        run: |
          scp -o StrictHostKeyChecking=no ${{ needs.build.outputs.artifact_name }} ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }}:${{ secrets.DROPLET_DEPLOY_PATH }}

      - name: Deploy on droplet
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.DROPLET_USER }}@${{ secrets.DROPLET_HOST }} << 'EOF'
            set -e  # Exit on any error

            # Load nvm if needed
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            nvm use 22

            cd ${{ secrets.DROPLET_DEPLOY_PATH }}
            ARTIFACT="${{ needs.build.outputs.artifact_name }}"
            DIR="${ARTIFACT%.tar.gz}"

            # Extract new build
            mkdir -p "$DIR"
            tar -xzf "$ARTIFACT" -C "$DIR"

            # Install production dependencies
            cd "$DIR"
            npm ci --omit=dev

            # (Optional) Run migrations if needed
            ENV_PATH=/etc/secrets/movie-management-api npm run migration:run:prod

            # Update symlink to new version
            cd ${{ secrets.DROPLET_DEPLOY_PATH }}
            rm -f current
            ln -sfn "$DIR" current

            # Restart PM2 application using ecosystem file
            cd current
            pm2 delete ecosystem.config.cjs 2>/dev/null || true
            pm2 start ecosystem.config.cjs --env production

            # Cleanup old artifact
            cd ${{ secrets.DROPLET_DEPLOY_PATH }}
            rm "$ARTIFACT"

            # Keep only last 10 versions
            ls -t | grep "^dist-v" | tail -n +11 | xargs -r rm -rf
          EOF
